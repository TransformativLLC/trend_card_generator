from pydantic_ai import Agent
from pydantic_ai.settings import ModelSettings
from pydantic_ai.models.google import GoogleModel, GoogleModelSettings
from google.genai.types import HarmBlockThreshold, HarmCategory

from src.models import TrendCard, TrendCardInput
from src.utils.configuration import load_config


class TrendCardEditor:
    """
    Handles the configuration, initialization, and operation of an agent used for generating trend cards.

    This class is designed to streamline the process of loading configurations, setting up prompt templates,
    and utilizing a preconfigured model to produce trend card components based on input data. The generated
    trend cards are produced asynchronously using a predefined agent and prompt system.

    Attributes:
        config (dict): The configuration dictionary loaded from the specified file.
        system_prompt (str): Predefined system prompt used by the agent.
        prompt_template (str): Template for generating prompts specific to trend cards.
        agent (Agent): Configured agent instance for generating trend cards.
    """

    def __init__(self, config_path: str = "src/agents/config", config_file_name: str = "trend_card_editor.yaml"):
        """
        Initializes an instance of a class that configures and creates an agent based on the provided
        configuration file. It loads configuration settings, stores prompt templates, and initializes
        an agent with the specified model and parameters.

        Args:
            config_path (str): Path to the configuration file. Defaults to "trend_card_agent.yaml".
        """

        # read config
        self.config = load_config(config_file_name, config_path)

        # save prompt templates
        self.system_prompt = self.config["system_prompt"]

        # create the agent
        # the Google API is different than those for OpenAI, Anthropic, etc., so need google-specific code
        settings = None
        model = None
        if self.config["model"].startswith("gemini"):
            settings = GoogleModelSettings(
                temperature=self.config.get("temperature", 0.5),
                max_tokens=self.config.get("max_tokens", 2048),
                google_thinking_config={'thinking_budget': self.config.get("thinking_budget", 2048)},
                google_safety_settings=[
                    {
                        'category': self.config.get("safety_settings_cateogry", HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT),
                        'threshold': self.config.get("safety_settings_threshold", HarmBlockThreshold.BLOCK_LOW_AND_ABOVE),
                    }
                ]
            )
            model = GoogleModel(self.config["model"])
        else:
            settings=ModelSettings(
                max_tokens=self.config.get("max_tokens", 2048),
                temperature=self.config.get("temperature", 0.5)
            )
            model=self.config["model"]

        self.agent = Agent(
            model=model,
            model_settings=settings,
            output_type=TrendCard,
            system_prompt=self.system_prompt,
            retries=self.config.get("generator_retries", 3)
        )


    async def edit_trend_card(self, trend_card_text: str) -> TrendCard:
        """
        Edits a trend card by processing the provided text through the agent.

        This method takes the input trend card text, processes it using the agent,
        and returns the resultant TrendCard object. It ensures that the trend card
        text is transformed or updated based on the agent's output.

        Args:
            trend_card_text (str): The text of the trend card to be edited.

        Returns:
            TrendCard: The transformed or updated trend card output generated by
                the agent.

        Raises:
            Exception: If the agent fails to process the input or another issue
                occurs during editing.
        """

        # create the finished prompt
        prompt = trend_card_text

        # Run the agent
        result = await self.agent.run(prompt)
        return result.output
